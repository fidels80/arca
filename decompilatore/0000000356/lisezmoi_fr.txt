Un décompilateur FoxPro écrit en FoxPro
(A FoxPro FoxPro decompiler)

Robert Plagnard
IngéLog Paris France
robert.plagnard@ingelog.fr



Résumé	2
Pourquoi ?	2
Installation	3
Réglages	3
Config.fpw	3
Dump.ini	3
Dvfp.ini	3
La section des préférences [Prefs]	3
La section du cosmétique [Cosmetic]	5
Projets	5
Bugs	5
Tutoriel	6
Première décompilation : Hello.fxp	6
Hello2.fxp	7
Décompilation d’un app : p1.app	8
Notions d’expression : Somme.fxp	9
Plus compliqué	10
Un conseil	10

 
Résumé
Le programme Dvfp est un « décompilateur » FoxPro écrit en FoxPro. Le programme Dump est un « décortiqueur » qui permet d’analyser la structure d’un fichier App ou apparenté. Dans l’esprit open source tous les projets et les programmes sources sont donnés. Tout se trouve dans dvfp.zip.
Pourquoi ?
Pourquoi écrire un décompilateur d’application FoxPro? Pourquoi l’écrire en FoxPro ? Et pourquoi le publier ? 
Pour répondre à la première question je dirais qu’il m’est arrivé parfois (mais rarement, heureusement !) de ne plus trop savoir qu’elle était la version installée sur une machine et donc d’avoir besoin de comparer des app ou des exe générés par FoxPro. Il m’est arrivé aussi, une fois, de perdre des sources et d’être bien content de pouvoir les reconstituer à partir d’éléments compilés. Cela peut arriver lorsqu’on distribue des applications en grand nombre.
Un autre intérêt d’un décompilateur est de comparer des sources qui sont très différents par les commentaires et/ou la présentation. Les comparateurs du genre windiff ou SourceSafe n’y retrouvent pas leurs petits. On compile alors les deux sources et on compare le résultat des deux décompilations.
Un autre argument est la compréhension que l’on en tire de FoxPro. On connaît beaucoup mieux FoxPro après qu’avant, c’est une évidence. Puis enfin, la dernière raison et non la moindre c’est le plaisir de la découverte, le fun quoi ! 
Le premier décompilateur que j’ai écris remonte à 1995, au début de FoxPro. Il était écrit en Delphi. A cette époque les machines étaient plus lentes et il ne me serait jamais venu à l’idée d’écrire un tel programme en FoxPro. Puis un jour de 2004 l’idée saugrenue m’est venue, pourquoi ne pas essayer avec FoxPro. Avec quelques classes bien faites l’écriture pouvait être agréable. Et puis, quel chalenge pour ce langage qui, bien que délaissé, reste d’une efficacité et d’un pragmatisme remarquables. Et voilà, c’est fait, ça marche bien, et ça démontre, s’il le fallait encore, que l’on peut faire beaucoup de chose avec VFP.
Je mets aujourd’hui ce code dans le domaine public, d’une part à des fins didactiques, d’autre part pour susciter les vocations, et  ainsi permettre à d’autres d’aller plus loin. En effet, bien que 99% du code se décompile correctement il reste bien, par ci par là,  quelque parties d’instruction qui ne sont pas terminées. Il n’y a probablement plus de grosses difficultés a surmonter mais on peut encore travailler sur ce code pour le rendre complet à 99.99%. Il n’y aurait pas non plus de difficultés à reconstituer le projet initial, où à rajouter une GUI (Graphical User Interface).  
Une dernière question est pourquoi ne pas décompiler les fichiers cryptés ? Il a deux raisons. La première et non la moindre est que (contrairement à ReFox par exemple) je ne connais pas la méthode utilisée par FoxPro pour crypter ses app. La deuxième est que je n’ai pratiquement jamais crypté mes applications et que ce décompilateur n’est pas fait pour pirater. 

Dans un premier temps je vais indiquer comment utiliser le décortiqueur et le décompilateur, ensuite viendra le temps d’expliquer comment ça marche si certains sont intéressés.
 
Installation
Tous les programmes et tous les sources sont dans le fichier Dvfp.zip. La première chose à faire est de décompresser le zip où bon vous semble. Vous devez obtenir un répertoire Dvfp dans lequel vous trouverez les fichiers suivants :
•	Dvfp.exe
•	Dvfp.ini
•	Dump.exe
•	Dump.ini
•	Config.fpw
•	Le projet Dvfp
•	Le projet Dump
et les répertoires suivants :
•	Prg
•	Oth
•	Test
Si vous avez le runtime ou la version de développement de VFP9 vous pourriez déjà double cliquer sur Dump.exe ou sur Dvfp.exe, vous seriez alors en présence d’un dialogue qui vous demanderait de choisir un fichier issu d’une compilation FoxPro (on reviendra la dessus plus tard). Mais il est préférable de lire la suite avant de lancer les programmes.
Réglages
Les deux programmes n’ont pratiquement pas d’interface visuelle. Ils sont pilotés par fichier INI. La seule interface homme machine est un dialogue de choix de fichier, éventuellement un écho sur le screen foxpro pour monter que ça travaille, et dans certaines conditions un fichier texte ouvert à la fin pour montrer le résultat du travail. On peut aussi utiliser ces programmes en mode batch. Dans VFP9 on peut aussi lancer « do Dump » ou « do Dvfp ». Je vais donc présenter ce que l’on peut paramétrer dans les fichiers INI, mais auparavant il faut dire deux mots de config.fpw
Config.fpw
Compte tenu de l’usage de la récursivité dans l’analyse des expressions, lorsque ces dernières sont un peu complexes, Dvfp.exe se plante assez vite en « stack overflow », c’est le cas en VFP8, donc oublions la version 8 de FoxPro. En VFP 9, par chance, on peut régler la profondeur de la stack, pour cela il faut mettre dans le fichier Config.fpw la directive :
Stacksize = 256
Cela est indispensable.
Dump.ini
Le décortiqueur Dump.exe est piloté par Dump.ini qui doit se trouver à coté de lui. Il permet de gérer quelques options de sorties. Cela peut avoir de l’importance quand l’APP est gros. Si toutes les sorties sont activées, un gros APP peut générer des centaines de milliers de lignes dans le fichier de sortie qui est créé dans le même répertoire que l’APP, de même nom que lui et d’extension .TXT (Attention à un éventuel fichier de ce nom déjà existant, il serait écrasé)

AppDump	indique si l’on commence par dumper la totalité du fichier APP
CodePartDump	indique si on dump les composants « code ».
OtherPartDump	indique si on dump les autres composants, inclus dans l’APP, comme les SCX, les VCX, les icones et autres tables.

Les deux derniers dumps font un peu doublons avec le premier mais pour comprendre de petits APP il est intéressant de les voir tous les 3.
	
LineTable	permet de dumper l’information qui permet à FoxPro de déterminer les numéros de lignes dans les sources. Cela n’a que peut d’intérêt pour la décompilation, mais mérite une explication, on verra plus tard.
Echo	permet d’afficher la progression du dump.
Dvfp.ini
Le décompilateur Dvfp.exe est piloté par Dvfp.ini qui doit se trouver à coté de lui. Il permet de gérer des préférences et quelques options dites cosmétiques.
La section des préférences [Prefs]

Decompile	permet de dire si l’on désire la décompilation ou non
Dump	permet d’indiquer si l’on désire le dump des instructions, une ligne de dump par instruction.

Ces deux options peuvent être actives en même temps, dans ce cas le dump est écrit avant l’interprétation en claire. Cela n’a pas beaucoup de sens de les désactiver en même temps.

Echo	permet d’afficher la progression de la décompilation.
DebugExpressions	peut être utilisé sur des petits programmes pour comprendre comment sont analysées les expressions en forme polonaise post fixées. Comme le volume de sortie est assez important, il faut en général désactiver cette option.
AllInOneFile	est une option intéressante pour faire des essais. Elle permet d’indiquer un nom de fichier unique pour toutes les sorties.

Si AllInOneFile est renseigné (ex : out.prg) , tout le code source décompilé sera écrit dans ce fichier et le fichier sera affiché à la fin de l’exécution. Dans le cas d’un .APP cela permet d’écrire dans un même fichier tous les PRG reconstitués et d’afficher le résultat immédiatement. C’est intéressant pour faire des essais rapides. Dans ce cas, et dans ce cas seulement, une liberté avec le langage a été prise,  à savoir l’ajout d’une procédure du nom du prg pour le code du prg qui n’est justement pas dans une procedure. Cela permet de tester la compilation du fichier unique sans erreur de compilation. Si AllInOneFile est vide cette liberté n’est pas prise.   
Si AllInOneFile n’est pas renseigné Dvfp décide lui-même des noms de fichiers en sortie. Il y a deux cas.
Dans le cas d’un  singleton ( nom.fxp ou nom.qpx ou nom.MPX, …) la sortie se fera respectivement dans un fichier nom.prg, ou nom.qpr, ou nom.mpr, … . Dans ce cas attention à vos fichiers sources s’ils se trouvent à coté du fxp (ou autres) ils risquent d’être écrasés.
Dans le cas d’un APP à plusieurs composants des répertoires spécifiques sont créés dans le répertoire de l’APP pour ranger les prg, les scx, les mpx, les vcx, les dbf, les oth (others)…. C’est très pratique mais cela nécessite un peu d’organisation. Avant de décompiler un APP (ou un EXE) il est donc conseillé de créer un répertoire du même nom que l’APP ou l’EXE et d’y recopier l’APP ou l’EXE à décompiler.

Dans le cas d’un EXE l’APP sera extrait automatiquement de l’EXE.   
La section du cosmétique [Cosmetic]
Cette section permet de gérer les commentaires générés par le décompilateur.

AppHeader	permet d’écrire le header de l’App
PartTable	permet d’écrire la table des composants de l’APP.
PartTitle	permet d’écrire le titre des composants
PartHeader	permet d’écrire le header de chaque composant
ProcBetween	permet d’indiquer un caractère pour séparer les déclarations de procédures (peut être la chaîne vide)
ClassBetween	permet d’indiquer un caractère qui permet de séparer les définitions de classes (peut être la chaîne vide).
Projets
Les projets sont donnés, il faudra accepter le changement de répertoire du projet au moment du chargement. Dans l’esprit « open source » vous pouvez vous approprier ces projets et leurs sources dans la mesure où l’avertissement qui se trouve dans dfox.prg est conservé.
Bugs
Il y a très probablement encore des bugs dans cette version. Je serais heureux de les connaître.
 
Tutoriel
En utilisant le Dump on remarquera très vite qu’il n’y a qu’un seul format, unique pour tous les fichiers compilés, qu’ils soient des .fxp des .app, des .mpx, des .mnx ou autres .qpx. Le format général est celui d’un .app. Un App est un conteneur qui contient un ou plusieurs modules. Les modules peuvent être du code compilé ou des fichiers inclus de différentes natures, des vcx/vct, des scx/sct, des tables, des icônes, etc… Les fxp, mpx, qpx sont en réalité des app ne comportant qu’un module de code. Les exe ou les dll créés par visual FoxPro sont en fait des chargeurs qui appellent le runtime et qui extraient un app que l’on retrouve tel que, à un certain endroit du fichier exe. Quand on leur donne un exe ou une dll Dump et Dvfp essayent de découvrir l’app dans l’exe et s’ils le trouvent, ils l’extraient à coté de l’exe ou de la dll, avec le même nom. Dans cette version, si l’app existe déjà, cela provoque une erreur, donc lorsque les deux existent, il faut choisir l’app !
Première décompilation : Hello.fxp
Soit le prg suivant :
Hello.prg
? 'Hello world'  

On le compile pour obtenir un Hello.fxp. Avec les options suivantes dans Dump.ini  :

AppDump = .F.
CodePartDump = .T. 
OtherPartDump = .F.
LineTable = .F.

L’analyse de Hello.fxp avec Dump donne :

Dump started 14/10/2006 19:57:36
APP HEADER of C:\DEV\DVFP2\DOC\HELLO.FXP
   Signature          F2FE
   Crypted            FF
   Engine             0220
   nbParts            0001
   MainPart           0001
   ^PartTable         000000B7
   ^PartNameTable     00000080
   PartNameTable size 00000037
   Idk(1)             00000000
   Idk(2)             00000000
   Idk(3)             00000000
   Idk(4)             00000000
   Idk(5)             0000
   Idk(6)             15B1

PART TABLE
   Part Type       Start       Next   FileType NameOffset    unused1    unused2  Name
      1   00    00000029   00000080   00000000   00000012   00000000   00000000  hello.fxp


PART hello.fxp
PART HEADER
   NbProc       0000
   NbClass      0000
   ^Main        00000025
   ^ProcTable   00000000
   ^ClassTable  00000000
   ^IdkTable1   00000047
   LineTableLen 00000002
   ^LineTable   00000043
   IdkBytes     F9 9D 4E 35 1C 00 00 00 FC 
PART DUMP
00000000  00 00 00 00 25 00 00 00-00 00 00 00 00 00 00 00   ....%...........
00000010  47 00 00 00 02 00 00 00-43 00 00 00 F9 9D 4E 35   G.......C...ù.N5
00000020  1C 00 00 00 FC 1A 00 17-00 02 F8 03 01 FC FB 0B   ................
00000030  00 48 65 6C 6C 6F 20 77-6F 72 6C 64 FD FE 03 00   .Hello world....
00000040  55 00 00 71 01 31 00 00-00 00 00 00 00 00 00 00   U..q.1..........
00000050  00 00 00 00 00 00 00                              .......

  Table1
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
Dump ended 14/10/2006 19:57:36

La décompilation de Hello.fxp donne (Cela dépend des options choisies dans Dvfp.ini)

   ? 'Hello world'  

On peut demander le dump des instructions dans Dvfp.ini, on obtient alors :


*/* C:\DEV\DVFP2\DOC\HELLO.FXP
*   22:05:38 : 1 Parts, Main = 1, Engine = 2.32
*   Part Entry Table Offset = 0x000000B7
*   Entry Name Table Offset = 0x00000080
*   Entry Name Table length = 0x00000037
*   Part Genre      Start       Next NameOffset       IDK1       IDK2       IDK3 Name
*      1     0         29         80         12          0          0          0 hello.fxp
*/* hello.fxp
*   debMain at offset 0x00000025
*   1 procs in ProcTable at offset 0x00000000
*   IDK1=47 IDK2=2 IDK3=0
*                                       0x00000025 0 -1
*/------------------------------------------------------------------------------
procedure hello  &&  added by dvfp when AllInOneFile is set
*/------------------------------------------------------------------------------
*  L=26, 0 variables :
   02 F8 03 01 FC FB 0B 00 48 65 6C 6C 6F 20 77 6F 72 6C 64 FD FE 
   ? 'Hello world'
   55 


*   0 classes in ClassTable at offset 0x00000000


L’instruction « ? ‘Hello world’ » est dumpée, sa représentation hexadécimale est :

02 F8 03 01 FC FB 0B 00 48 65 6C 6C 6F 20 77 6F 72 6C 64 FD FE

02	Code de l’instruction « ? »
F8 03 01	Constante 1, (indique qu’il y a un argument)
FC	début d’expression
FB	début de chaine type pascal
0B 00	11 (longueur de la chaine)
48 65 .. 64 les 11 caractères de la chaine “Hello world”
FD	fin d’expression
FE	fin d’instruction
Hello2.fxp
Hello2.prg
#include foxpro.h
MessageBox( 'Hello world', MB_ICONEXCLAMATION + MB_YESNO )

Dvfp donne :

   MessageBox('Hello world',52)

En effet les includes et les constantes ne peuvent pas être retrouvées. On remarque même, au passage, que FoxPro calcule les expressions formées de constantes (48 + 4). 
Décompilation d’un app : p1.app
Lorsqu’on décompile tout les programmes d’un APP dans un même fichier on rencontre le problème des instructions hors procédure dès le deuxième prg. En effet on ne peut pas avoir d’instructions hors procédure après la première procédure ou fonction.

Exemple :
Soit un App composé des deux prg suivants :

p1.prg
   do One
   do p2
procedure One
   ? ‘One’
endproc

Et

 p2.prg
do Two
procedure Two
  ? ‘Two’
endproc

A la décompilation de l’App dans un même fichier on obtient :

procedure p1  &&  added by dvfp when AllInOneFile is set
   do oNe
   do P2

procedure One
   ? 'One'
endproc


procedure p2  &&  added by dvfp when AllInOneFile is set
   do Two

procedure two
   ? 'two'
endproc
   
On remarquera les deux instructions « procedure » ajoutées au début de chaque prg. Ainsi il n’y a plus de problème pour tester la recompilation du code. C’est pratique pour tester la recompilation mais le programme n’est pas équivalent, il peut même ne pas tourner du tout. Lorsqu’on décompile dans des fichiers séparés ces instructions ne sont bien sûr pas ajoutées afin d’obtenir des sources corrects.

Notions d’expression : Somme.fxp
Pour donner une idée de la compilation des expressions, examinons le petit programme :

Somme.prg
local x, y, z
x = 1
y = 255
z = x + 2 * y
? z

La décompilation de Somme.fxp (avec Dump=.T.) donne
…
*  L=75, 3 variables :
*  0000 x
*  0001 y
*  0002 z
   AE F7 00 00 07 F7 01 00 07 F7 02 00 FE 
   local x, y, z
   54 F7 00 00 10 FC F8 01 01 FD FE 
   x = 1
   54 F7 01 00 10 FC F8 03 FF FD FE 
   y = 255
   54 F7 02 00 10 FC F7 00 00 F8 01 02 F5 0D F7 01 00 04 06 FD FE 
   z = x+2*m.y
   02 F8 03 01 F7 02 00 FE 
   ? z
…

L’analyse de la première instruction est la suivante :
AE 	code de l’instruction local,
F7 00 00 	variable x
07	virgule
F7 01 00 	variable y
07	virgule
F7 02 00	variable z
FE	fin d’instruction

La deuxième instruction :
54	code de l’instruction d’affectation
F7 00 00	x
10	=
FC	début d’expression
F8 01 01	Constante 1 (de largeur 1)
FD	fin d’expression
FE	fin d’instruction

La troisième instruction :
54	affectation
F7 01 00	y
10	=
FC	début d’expression
F8 03 FF	Constante 255 (de largeur 3)
FD	fin d’expression
FE	fin d’instruction

Et enfin une expression simple :
54	affectation
F7 02 00	z
10	=
FC	début d’expression
F7 00 00	x
F8 01 02	2
F5 0D 	m.
F7 01 00	y
04	*
06	+
0D	fin d’expression

On constate  ainsi que l’expression est stockée sous forme polonaise post-fixée.
Plus compliqué
Vous pouvez utiliser Dump ou Dvfp sur eux même (mais dans le répertoires Test\Dvfp ou Test\Dump). Une fois que l’APP aura été extrait de l’EXE il faudra choisir directement l’APP, sinon on obtient une erreur (C’est un petit défaut que l’on pourra corriger).
Un conseil
Pour dumper des app assez long, dans Dump.ini ne demander que CodePartDump :
[Options]
AppDump = .F.
CodePartDump = .T. 
OtherPartDump = .F.
LineTable = .F.

Pour décompiler des app de grande taille (ou des exe/dll produits par FoxPro)  ne demander dans Dvfp.ini que la décompilation :

[prefs]
Decompile = .T.	
Dump = .F.
Echo = .T.				
AllInOneFile = 
DebugExpressions = .F.

[Cosmetic]
AppHeader = .F.
PartTable = .F.
PartTitle = .F.
Partheader = .F.
ProcBetween = - 
ClassBetween = =

Dans ce cas vous n’aurez pas de résultat affichés à la fin car toutes les productions auront été mises dans des répertoires créés (si besoin est) à cette occasion. Allez voir dans les répertoires prg, scx, vcx, mpx, qpx, ou oth les résultats de la décompilation.
